<!DOCTYPE html>


<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  
  <title>genieclust.Genie &mdash; genieclust</title>
  

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/plot_directive.css" type="text/css" />
  <link rel="stylesheet" href="_static/graphviz.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/custom.css" type="text/css" />

  
  

  
  

  
    <link rel="canonical" href="https://genieclust.gagolewski.com/genieclust_genie.html" />

  
  <!--[if lt IE 9]>
    <script src="_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["\\(", "\\)"]], "displayMath": [["\\[", "\\]"]], "processRefs": false, "processEnvironments": false}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="genieclust.compare_partitions" href="genieclust_compare_partitions.html" />
    <link rel="prev" title="Python Package genieclust Reference" href="genieclust.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="index.html" class="icon icon-home"> genieclust
          

          
          </a>

          
            
            
              <div class="version">
                1.0.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        
        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">genieclust</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="index.html">About</a></li>
</ul>
<p class="caption"><span class="caption-text">Examples and Tutorials</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="weave/basics.html">Basics</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/sklearn_toy_example.html">Comparing Algorithms on Toy Datasets</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/benchmarks_ar.html">Benchmarks (How Good Is It?)</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/timings.html">Timings (How Fast Is It?)</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/noise.html">Clustering with Noise Points Detection</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/sparse.html">Example: Sparse Data and Movie Recommendation</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/string.html">Example: String Data and Grouping of DNA</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/r.html">R Interface Examples</a></li>
</ul>
<p class="caption"><span class="caption-text">API Documentation</span></p>
<ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="genieclust.html">Python Package <cite>genieclust</cite> Reference</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#">genieclust.Genie</a></li>
<li class="toctree-l2"><a class="reference internal" href="genieclust_compare_partitions.html">genieclust.compare_partitions</a></li>
<li class="toctree-l2"><a class="reference internal" href="genieclust_inequity.html">genieclust.inequity</a></li>
<li class="toctree-l2"><a class="reference internal" href="genieclust_internal.html">genieclust.internal</a></li>
<li class="toctree-l2"><a class="reference internal" href="genieclust_plots.html">genieclust.plots</a></li>
<li class="toctree-l2"><a class="reference internal" href="genieclust_tools.html">genieclust.tools</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="rapi.html">R Package <em>genieclust</em> Reference</a></li>
</ul>
<p class="caption"><span class="caption-text">Other</span></p>
<ul>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/genieclust">Source Code (GitHub)</a></li>
<li class="toctree-l1"><a class="reference external" href="https://github.com/gagolews/genieclust/issues">Bug Tracker and Feature Suggestions</a></li>
<li class="toctree-l1"><a class="reference external" href="https://pypi.org/project/genieclust/">PyPI Entry</a></li>
<li class="toctree-l1"><a class="reference external" href="https://cran.r-project.org/web/packages/genieclust/">CRAN Entry</a></li>
<li class="toctree-l1"><a class="reference external" href="https://www.gagolewski.com/">Author's Homepage</a></li>
<li class="toctree-l1"><a class="reference internal" href="news.html">What Is New in <em>genieclust</em></a></li>
</ul>
<p class="caption"><span class="caption-text">Appendix</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="weave/benchmarks_details.html">Benchmarks — Detailed Results</a></li>
<li class="toctree-l1"><a class="reference internal" href="weave/benchmarks_approx.html">Benchmarks — Approximate Method</a></li>
<li class="toctree-l1"><a class="reference internal" href="z_bibliography.html">References</a></li>
</ul>

            
          
        </div>
        
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">genieclust</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content style-external-links">
        
          

















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html" class="icon icon-home"></a> &raquo;</li>
        
          <li><a href="genieclust.html">Python Package <cite>genieclust</cite> Reference</a> &raquo;</li>
        
      <li>genieclust.Genie</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
    
  </ul>

  
  <div class="rst-breadcrumbs-buttons" role="navigation" aria-label="breadcrumb navigation">
      
        <a href="genieclust_compare_partitions.html" class="btn btn-neutral float-right" title="genieclust.compare_partitions" accesskey="n">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
      
      
        <a href="genieclust.html" class="btn btn-neutral float-left" title="Python Package genieclust Reference" accesskey="p"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
      
  </div>
  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="genieclust-genie">
<h1>genieclust.Genie<a class="headerlink" href="#genieclust-genie" title="Permalink to this headline">¶</a></h1>
<dl class="py class">
<dt id="genieclust.Genie">
<em class="property"><span class="pre">class</span> </em><code class="sig-prename descclassname"><span class="pre">genieclust.</span></code><code class="sig-name descname"><span class="pre">Genie</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">n_clusters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">2</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">*</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gini_threshold</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.3</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">M</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">affinity</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'l2'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exact</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_full_tree</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">compute_all_cuts</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">postprocess</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'boundary'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">cast_float32</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mlpack_enabled</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'auto'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mlpack_leaf_size</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmslib_n_neighbors</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">64</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmslib_params_init</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'method':</span> <span class="pre">'hnsw'}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmslib_params_index</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{'post':</span> <span class="pre">2}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nmslib_params_query</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">{}</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">verbose</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#genieclust.Genie" title="Permalink to this definition">¶</a></dt>
<dd><p>Genie++ hierarchical clustering algorithm</p>
<dl class="field-list">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl>
<dt><strong>n_clusters</strong><span class="classifier">int</span></dt><dd><p>Number of clusters to detect.</p>
<p>If <cite>M</cite> &gt; 1 and <cite>postprocess</cite> is not <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>, <cite>n_clusters</cite> = 1
can act as a noise point/outlier detector.
The approximate method (see parameter <cite>exact</cite>) can sometimes
fail to detect the coarsest-grained partitions; in such a case,
more clusters might be returned (with a warning).</p>
</dd>
<dt><strong>gini_threshold</strong><span class="classifier">float</span></dt><dd><p>Threshold for the Genie correction in [0,1].</p>
<p>The Gini index is used to quantify the inequality of the cluster
size distribution. Low thresholds highly penalise the formation
of small clusters. Threshold of 1.0 disables the correction
and for <cite>M</cite> = 1 makes the method be equivalent to the single
linkage algorithm.</p>
<p>The algorithm tends to be <em>stable</em> with respect to small changes
to the threshold — they do not tend to affect the output clustering.
Usually, thresholds of 0.1, 0.3, 0.5, and 0.7 are worth giving a try.</p>
</dd>
<dt><strong>M</strong><span class="classifier">int</span></dt><dd><p>Smoothing factor for the mutual reachability distance <a class="reference internal" href="#r6050e59d50fb-6" id="id1">[6]</a>.</p>
<p><cite>M</cite> = 1 gives the original Genie algorithm  <a class="reference internal" href="#r6050e59d50fb-1" id="id2">[1]</a> (with no noise point
detection) with respect to the chosen affinity as-is. Note that
for <cite>M &gt; 1</cite> we need additionally <span class="math notranslate nohighlight">\(O(M n)\)</span> working memory
for storing of points’ nearest neighbours.</p>
</dd>
<dt><strong>affinity</strong><span class="classifier">str</span></dt><dd><p>Metric used to compute the linkage.</p>
<ul>
<li><p>For <cite>exact</cite> = <code class="docutils literal notranslate"><span class="pre">True</span></code>:</p>
<p>One of:
<code class="docutils literal notranslate"><span class="pre">&quot;l2&quot;</span></code> (synonym: <code class="docutils literal notranslate"><span class="pre">&quot;euclidean&quot;</span></code>),
<code class="docutils literal notranslate"><span class="pre">&quot;l1&quot;</span></code> (synonym: <code class="docutils literal notranslate"><span class="pre">&quot;manhattan&quot;</span></code>, <code class="docutils literal notranslate"><span class="pre">&quot;cityblock&quot;</span></code>),
<code class="docutils literal notranslate"><span class="pre">&quot;cosinesimil&quot;</span></code> (synonym: <code class="docutils literal notranslate"><span class="pre">&quot;cosine&quot;</span></code>), or
<code class="docutils literal notranslate"><span class="pre">&quot;precomputed&quot;</span></code>.</p>
<p>In the latter case, the <cite>X</cite> argument to the <cite>fit</cite> method
must be a distance vector or a square-form distance matrix, see <cite>scipy.spatial.distance.pdist</cite>.</p>
</li>
<li><p>For <cite>exact</cite> = <code class="docutils literal notranslate"><span class="pre">False</span></code>:</p>
<p>Any dissimilarity supported by <cite>nmslib</cite>, see <a class="reference internal" href="#r6050e59d50fb-5" id="id3">[5]</a> and
<a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/spaces.md">https://github.com/nmslib/nmslib/blob/master/manual/spaces.md</a>,
for instance:
<code class="docutils literal notranslate"><span class="pre">&quot;l2&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;l2_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;l1&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;l1_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;linf&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;linf_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;cosinesimil&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;cosinesimil_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;negdotprod&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;negdotprod_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;angulardist&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;angulardist_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;leven&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;normleven&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;jaccard_sparse&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;bit_jaccard&quot;</span></code>,
<code class="docutils literal notranslate"><span class="pre">&quot;bit_hamming&quot;</span></code>.</p>
</li>
</ul>
</dd>
<dt><strong>exact</strong><span class="classifier">bool</span></dt><dd><p>Whether to compute the minimum spanning tree exactly or rather
estimate it based on an approximate near-neighbour graph.</p>
<p>The exact method has time complexity of <span class="math notranslate nohighlight">\(O(d n^2)\)</span> <a class="reference internal" href="#r6050e59d50fb-2" id="id4">[2]</a>
(however, see <cite>mlpack_enabled</cite>) but only needs <span class="math notranslate nohighlight">\(O(n)\)</span> memory.</p>
<p>If <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>, the minimum spanning tree is approximated
based on an approximate <span class="math notranslate nohighlight">\(k\)</span>-nearest neighbours graph found by
<cite>nmslib</cite> <a class="reference internal" href="#r6050e59d50fb-5" id="id5">[5]</a>. This is typically very fast but requires
<span class="math notranslate nohighlight">\(O(k n)\)</span> memory.</p>
</dd>
<dt><strong>compute_full_tree</strong><span class="classifier">bool</span></dt><dd><p>Whether to determine the whole cluster hierarchy and the
linkage matrix.</p>
<p>Only available if <cite>M</cite> = 1 and <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.
Enables plotting of dendrograms or cutting
of the hierarchy at an arbitrary level, see the
<cite>children_</cite>, <cite>distances_</cite>, <cite>counts_</cite> attributes.</p>
</dd>
<dt><strong>compute_all_cuts</strong><span class="classifier">bool</span></dt><dd><p>Whether to compute the requested <cite>n_clusters</cite>-partition and all
the coarser-grained ones.</p>
<p>If <code class="docutils literal notranslate"><span class="pre">True</span></code>, then the <cite>labels_</cite> attribute will be a matrix, see below.</p>
</dd>
<dt><strong>postprocess</strong><span class="classifier">{“boundary”, “none”, “all”}</span></dt><dd><p>Controls the treatment of noise points after the clusters are
identified.</p>
<p>In effect only if <cite>M</cite> &gt; 1. Each leaf in the minimum spanning tree
is treated as a <em>noise</em> point. We call it a <em>boundary point</em>
if it is amongst its adjacent vertex’s <cite>M</cite> - 1 nearest neighbours.
By default, only boundary points are merged with their nearest
<em>core</em> points.</p>
<p>To force a classical <cite>n_clusters</cite>-partition
of a data set (with no notion of noise), choose <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>.
Furthermore, <code class="docutils literal notranslate"><span class="pre">&quot;none&quot;</span></code> leaves all leaves, i.e., noise points
(including the boundary ones) as-is.</p>
</dd>
<dt><strong>cast_float32</strong><span class="classifier">bool</span></dt><dd><p>Whether casting of data type to <code class="docutils literal notranslate"><span class="pre">float32</span></code> is to be performed.</p>
<p>If <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it decreases the run-time ca. 2 times
at a cost of greater memory use. Otherwise, note that <cite>nmslib</cite>
<em>requires</em> <code class="docutils literal notranslate"><span class="pre">float32</span></code> data anyway when using dense or sparse
numeric matrix inputs.</p>
<p>By setting <cite>cast_float32</cite> to <code class="docutils literal notranslate"><span class="pre">False</span></code> a user assures themself
that the inputs are of acceptable form.</p>
</dd>
<dt><strong>mlpack_enabled</strong><span class="classifier">“auto” or bool</span></dt><dd><p>Whether <cite>mlpack.emst</cite> should be used for computing the Euclidean
minimum spanning tree instead of the Jarník-Prim algorithm
when <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>Often fast for very low-dimensional spaces. As the name suggests,
only <cite>affinity</cite> of <code class="docutils literal notranslate"><span class="pre">'l2'</span></code> is supported (and <cite>M</cite> = 1).
By default, we rely on <cite>mlpack</cite> if it is installed and
<cite>n_features</cite> &lt;= 6.</p>
</dd>
<dt><strong>mlpack_leaf_size</strong><span class="classifier">int</span></dt><dd><p>Leaf size in the kd-tree when <cite>mlpack.emst</cite> is used.</p>
<p>According to the <cite>mlpack</cite> manual, leaves of size 1 give the best
performance at the cost of greater memory use.</p>
</dd>
<dt><strong>nmslib_n_neighbors</strong><span class="classifier">int</span></dt><dd><p>The number of approximate nearest neighbours used to estimate
the minimum spanning tree when when <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>If the number of nearest neighbours is too small, the nearest
neighbour graph might be disconnected and the number of obtained
clusters might be greater than the requested one.</p>
<p><cite>nmslib_n_neighbors</cite> must not be less than <cite>M</cite> - 1.</p>
</dd>
<dt><strong>nmslib_params_init</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of parameters to be passed to <cite>nmslib.init</cite>
when <cite>exact</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>See <a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/methods.md">https://github.com/nmslib/nmslib/blob/master/manual/methods.md</a>,
<a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/spaces.md">https://github.com/nmslib/nmslib/blob/master/manual/spaces.md</a>
and <a class="reference external" href="https://nmslib.github.io/nmslib/">https://nmslib.github.io/nmslib/</a>
for more details. The <cite>space</cite>, <cite>data_type</cite>, and <cite>dtype</cite> parameters
will be set based on the chosen <cite>affinity</cite> and the input <cite>X</cite>.</p>
</dd>
<dt><strong>nmslib_params_index</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of parameters to be passed to <cite>index.createIndex</cite>,
where <cite>index</cite> is the object constructed with <cite>nmslib.init</cite>.</p>
<p>The <cite>indexThreadQty</cite> parameter will be set based on the
<code class="docutils literal notranslate"><span class="pre">OMP_NUM_THREADS</span></code> environment variable.</p>
</dd>
<dt><strong>nmslib_params_query</strong><span class="classifier">dict</span></dt><dd><p>A dictionary of parameters to be passed to <cite>index.setQueryTimeParams</cite>,
where <cite>index</cite> is the object constructed with <cite>nmslib.init</cite>.</p>
</dd>
<dt><strong>verbose</strong><span class="classifier">bool</span></dt><dd><p>Whether to print diagnostic messages and progress information
on <code class="docutils literal notranslate"><span class="pre">stderr</span></code>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p><strong>Genie</strong> is a robust and outlier resistant
hierarchical clustering algorithm <a class="reference internal" href="#r6050e59d50fb-1" id="id6">[1]</a>, originally published
as an R package <code class="docutils literal notranslate"><span class="pre">genie</span></code>. This new implementation is, amongst others,
much faster and now features optional smoothing and noise
point detection (if <cite>M</cite> &gt; 1).</p>
<p>Genie is based on a minimum spanning tree (MST) of the
pairwise distance graph of a given point set.
Just like the single linkage, it consumes the edges
of the MST in increasing order of weights. However, it prevents
the formation of clusters of highly imbalanced sizes; once the Gini index
of the cluster size distribution raises above an assumed threshold,
a forced merge of a point group of the smallest size is performed.
Its appealing simplicity goes hand in hand with its usability;
Genie often outperforms other clustering approaches on benchmark data.</p>
<p>The Genie algorithm itself has <span class="math notranslate nohighlight">\(O(n \sqrt{n})\)</span> time
and <span class="math notranslate nohighlight">\(O(n)\)</span> memory complexity provided that a minimum spanning
tree of the pairwise distance graph is given.
Generally, our parallelised implementation of a Jarník (Prim/Dijkstra)-like
method <a class="reference internal" href="#r6050e59d50fb-2" id="id7">[2]</a> will be called to compute an MST, which takes <span class="math notranslate nohighlight">\(O(d n^2)\)</span> time.
However, <cite>mlpack</cite> <a class="reference internal" href="#r6050e59d50fb-3" id="id8">[3]</a> provides a very fast
alternative in the case of Euclidean spaces of (very) low dimensionality
and <cite>M</cite> = 1, see <a class="reference internal" href="#r6050e59d50fb-4" id="id9">[4]</a> and the <cite>mlpack_enabled</cite> parameter.
Moreover, in the approximate method (<cite>exact</cite> = <code class="docutils literal notranslate"><span class="pre">False</span></code>) we apply
the Kruskal algorithm on the near-neighbour graph determined
by <cite>nmslib</cite> <a class="reference internal" href="#r6050e59d50fb-5" id="id10">[5]</a>. Albeit this only gives <em>some</em> sort of a spanning <em>forest</em>,
such a data structure turns out to be very suitable for our clustering task
(note that the set of connected components will determine the top
level of the identified cluster hierarchy).</p>
<p>The Genie correction together with the smoothing factor <cite>M</cite> &gt; 1
gives a robustified version of the HDBSCAN* <a class="reference internal" href="#r6050e59d50fb-6" id="id11">[6]</a> algorithm that,
contrary to its predecessor, is able to detect a <em>predefined</em> number of
clusters. Hence, it is independent of the <em>DBSCAN</em>’s somewhat magical
<code class="docutils literal notranslate"><span class="pre">eps</span></code> parameter or the <em>HDBSCAN</em>’s <code class="docutils literal notranslate"><span class="pre">min_cluster_size</span></code> one.
If <cite>M</cite> &gt; 1, then the minimum spanning tree is computed with respect to the
mutual reachability distance (based, e.g., on the Euclidean metric).
Formally, the distance <span class="math notranslate nohighlight">\(m(i,j)\)</span> is used instead of the
chosen “raw” distance, <span class="math notranslate nohighlight">\(d(i,j)\)</span>. It holds
<span class="math notranslate nohighlight">\(m(i,j)=\max(d(i,j), c(i), c(j))\)</span>,
where the “core” distance <span class="math notranslate nohighlight">\(c(i)\)</span> is given by
<span class="math notranslate nohighlight">\(d(i,k)\)</span> with <span class="math notranslate nohighlight">\(k\)</span> being the (<cite>M</cite> - 1)-th nearest neighbour
of <span class="math notranslate nohighlight">\(i\)</span>. This makes “noise” and “boundary” points being “pulled away”
from each other, however, note that <cite>M</cite> = 2 corresponds to the
original distance. During the clustering procedure, all leaves of the MST
do not take part in the clustering process. They may be merged
with the nearest clusters during the postprocessing stage,
or left marked as “noise” observations.</p>
<dl class="field-list simple">
<dt class="field-odd">Environment variables</dt>
<dd class="field-odd"><dl class="simple">
<dt>OMP_NUM_THREADS</dt><dd><p>Controls the number of threads used for computing the minimum
spanning tree (not supported by <cite>mlpack</cite>).</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r6050e59d50fb-1"><span class="brackets">1</span><span class="fn-backref">(<a href="#id2">1</a>,<a href="#id6">2</a>)</span></dt>
<dd><p>Gagolewski M., Bartoszuk M., Cena A.,
Genie: A new, fast, and outlier-resistant hierarchical
clustering algorithm, <em>Information Sciences</em> 363, 2016, 8-23.
doi:10.1016/j.ins.2016.05.003.</p>
</dd>
<dt class="label" id="r6050e59d50fb-2"><span class="brackets">2</span><span class="fn-backref">(<a href="#id4">1</a>,<a href="#id7">2</a>)</span></dt>
<dd><p>Olson C.F., Parallel algorithms for hierarchical clustering,
<em>Parallel Computing</em> 21(8), 1995, 1313-1325.
doi:10.1016/0167-8191(95)00017-I.</p>
</dd>
<dt class="label" id="r6050e59d50fb-3"><span class="brackets"><a class="fn-backref" href="#id8">3</a></span></dt>
<dd><p>Curtin R.R., Edel M., Lozhnikov M., Mentekidis Y., Ghaisas S., Zhang S.,
mlpack 3: A fast, flexible machine learning library,
<em>Journal of Open Source Software</em> 3(26), 726, 2018.
doi:10.21105/joss.00726.</p>
</dd>
<dt class="label" id="r6050e59d50fb-4"><span class="brackets"><a class="fn-backref" href="#id9">4</a></span></dt>
<dd><p>March W.B., Ram P., Gray A.G.,
Fast Euclidean Minimum Spanning Tree: Algorithm, Analysis, and Applications,
<em>Proc. ACM SIGKDD’10</em>, 2010, 603-611.</p>
</dd>
<dt class="label" id="r6050e59d50fb-5"><span class="brackets">5</span><span class="fn-backref">(<a href="#id3">1</a>,<a href="#id5">2</a>,<a href="#id10">3</a>)</span></dt>
<dd><p>Naidan B., Boytsov L., Malkov Y.,  Novak D.,
<em>Non-metric space library (NMSLIB) manual</em>, version 2.0, 2019.
<a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/latex/manual.pdf">https://github.com/nmslib/nmslib/blob/master/manual/latex/manual.pdf</a>.</p>
</dd>
<dt class="label" id="r6050e59d50fb-6"><span class="brackets">6</span><span class="fn-backref">(<a href="#id1">1</a>,<a href="#id11">2</a>)</span></dt>
<dd><p>Campello R., Moulavi D., Zimek A., Sander J.,
Hierarchical density estimates for data clustering, visualization,
and outlier detection,
<em>ACM Transactions on Knowledge Discovery from Data</em> 10(1),
2015, 5:1–5:51. doi:10.1145/2733381.</p>
</dd>
</dl>
<dl class="field-list">
<dt class="field-odd">Attributes</dt>
<dd class="field-odd"><dl>
<dt><strong>labels_</strong><span class="classifier">ndarray</span></dt><dd><p>Detected cluster labels.</p>
<p>If <cite>compute_all_cuts</cite> is <code class="docutils literal notranslate"><span class="pre">False</span></code> (the default),
this is an integer vector such that <code class="docutils literal notranslate"><span class="pre">labels_[i]</span></code> gives
the cluster ID (between 0 and <cite>n_clusters_</cite> - 1) of the i-th object.
If <cite>M</cite> &gt; 1, noise points are labelled -1 (unless taken care of in the
postprocessing stage).</p>
<p>Otherwise, i.e., if <cite>compute_all_cuts</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>,
all partitions of cardinality down to <cite>n_clusters</cite>
are determined; <code class="docutils literal notranslate"><span class="pre">labels_[j,i]</span></code> denotes the cluster ID of the i-th
point in a j-partition. We assume that both the 0- and 1- partition
distinguishes only between noise- and non-noise points,
however, no postprocessing is conducted on the 0-partition
(there might be points with labels of -1 even if <cite>postprocess</cite>
is <code class="docutils literal notranslate"><span class="pre">&quot;all&quot;</span></code>).</p>
<p>Note that the approximate method (<cite>exact</cite> of <code class="docutils literal notranslate"><span class="pre">False</span></code>) might fail
to determine the fine-grained clusters (if the approximate
neighbour graph is disconnected) - the actual number of clusters
detected can be larger.</p>
</dd>
<dt><strong>n_clusters_</strong><span class="classifier">int</span></dt><dd><p>The actual number of clusters detected by the algorithm.</p>
<p>As we argued above, the approximate method might sometimes yield
a more fine-grained partition than the requested one (with a warning).
Moreover, there might be too many noise points in the dataset.</p>
</dd>
<dt><strong>n_samples_</strong><span class="classifier">int</span></dt><dd><p>The number of points in the fitted dataset.</p>
</dd>
<dt><strong>n_features_</strong><span class="classifier">int</span></dt><dd><p>The number of features in the fitted dataset.</p>
<p>If the information is not available, it is be set to -1.</p>
</dd>
<dt><strong>children_</strong><span class="classifier">None or ndarray</span></dt><dd><p>If <cite>compute_full_tree</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this is a matrix whose
i-th row provides the information on the clusters merged in
the i-th iteration. See the description of <code class="docutils literal notranslate"><span class="pre">Z[:,0]</span></code> and <code class="docutils literal notranslate"><span class="pre">Z[:,1]</span></code>
in <cite>scipy.cluster.hierarchy.linkage</cite>. Together with <cite>distances_</cite> and
<cite>counts_</cite>, this constitutes the linkage matrix that can be used for
plotting the dendrogram.</p>
</dd>
<dt><strong>distances_</strong><span class="classifier">None or ndarray</span></dt><dd><p>If <cite>compute_full_tree</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this is a vector that gives
the distance between two clusters merged in each iteration,
see the description of <code class="docutils literal notranslate"><span class="pre">Z[:,2]</span></code> in <cite>scipy.cluster.hierarchy.linkage</cite>.</p>
<p>As the original Genie algorithm does not guarantee that that distances
are ordered increasingly (there are other hierarchical
clustering linkages that violate the ultrametricity property as well),
these are corrected by applying
<code class="docutils literal notranslate"><span class="pre">distances_</span> <span class="pre">=</span> <span class="pre">genieclust.tools.cummin(distances_[::-1])[::-1]</span></code>.</p>
</dd>
<dt><strong>counts_</strong><span class="classifier">None or ndarray</span></dt><dd><p>If <cite>compute_full_tree</cite> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, this is a vector giving
the number of elements in a cluster created in each iteration.
See the description of <code class="docutils literal notranslate"><span class="pre">Z[:,3]</span></code> in <cite>scipy.cluster.hierarchy.linkage</cite>.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Methods</p>
<table class="longtable docutils align-default">
<colgroup>
<col style="width: 10%" />
<col style="width: 90%" />
</colgroup>
<tbody>
<tr class="row-odd"><td><p><a class="reference internal" href="#genieclust.Genie.fit" title="genieclust.Genie.fit"><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit</span></code></a>(X[, y])</p></td>
<td><p>Perform cluster analysis of a dataset.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">fit_predict</span></code>(X[, y])</p></td>
<td><p>Perform cluster analysis of a dataset and return the predicted labels.</p></td>
</tr>
<tr class="row-odd"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">get_params</span></code>([deep])</p></td>
<td><p>Get parameters for this estimator.</p></td>
</tr>
<tr class="row-even"><td><p><code class="xref py py-obj docutils literal notranslate"><span class="pre">set_params</span></code>(**params)</p></td>
<td><p>Set the parameters of this estimator.</p></td>
</tr>
</tbody>
</table>
<dl class="py method">
<dt id="genieclust.Genie.fit">
<code class="sig-name descname"><span class="pre">fit</span></code><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">y</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#genieclust.Genie.fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Perform cluster analysis of a dataset.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><dl class="simple">
<dt><strong>X</strong><span class="classifier">object</span></dt><dd><p>Typically a matrix with <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> rows and <code class="docutils literal notranslate"><span class="pre">n_features</span></code>
columns, see below for more details and options.</p>
</dd>
<dt><strong>y</strong><span class="classifier">None</span></dt><dd><p>Ignored.</p>
</dd>
</dl>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><dl class="simple">
<dt><strong>self</strong><span class="classifier">genieclust.Genie</span></dt><dd><p>The object that the method was called on.</p>
</dd>
</dl>
</dd>
</dl>
<p class="rubric">Notes</p>
<p>Refer to the <cite>labels_</cite> and <cite>n_clusters_</cite> attributes for the result.</p>
<p>Acceptable <cite>X</cite> types depend whether we use the exact or the approximate
method.</p>
<ul>
<li><p><cite>X</cite> when <cite>exact</cite> = <code class="docutils literal notranslate"><span class="pre">True</span></code>.</p>
<p>For <cite>affinity</cite> of <code class="docutils literal notranslate"><span class="pre">&quot;precomputed&quot;</span></code>, <cite>X</cite> should either
be a distance vector of length <code class="docutils literal notranslate"><span class="pre">n_samples*(n_samples-1)/2</span></code>
(see <cite>scipy.spatial.distance.pdist</cite>) or a square distance matrix
of shape <code class="docutils literal notranslate"><span class="pre">(n_samples,</span> <span class="pre">n_samples)</span></code>
(see <cite>scipy.spatial.distance.squareform</cite>).</p>
<p>Otherwise, <cite>X</cite> should be real-valued matrix
(dense <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>, or an object coercible to)
with <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> rows and <code class="docutils literal notranslate"><span class="pre">n_features</span></code> columns.</p>
<p>In the latter case, it might be a good idea to standardise
or at least somehow preprocess the coordinates of the input data
points by calling, for instance,
<code class="docutils literal notranslate"><span class="pre">X</span> <span class="pre">=</span> <span class="pre">(X-X.mean(axis=0))/X.std(axis=None,</span> <span class="pre">ddof=1)</span></code>
so that the dataset is centred at 0 and has total variance of 1.
This way the method becomes translation and scale invariant.
What’s more, if data are recorded with small precision (say, up
to few decimal digits), adding a tiny bit of Gaussian noise will
assure the solution is unique (note that this generally applies
to other distance-based clustering algorithms as well).</p>
</li>
<li><p><cite>X</cite> when <cite>exact</cite> = <code class="docutils literal notranslate"><span class="pre">False</span></code>.</p>
<p>The approximate method relies on <cite>nmslib</cite> for locating the
nearest neighbours. Therefore, it supports all datatypes
described in <a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/spaces.md">https://github.com/nmslib/nmslib/blob/master/manual/spaces.md</a>.
Depending on the chosen <cite>affinity</cite>, <cite>X</cite> may hence be
a real-valued <code class="docutils literal notranslate"><span class="pre">numpy.ndarray</span></code> matrix with <code class="docutils literal notranslate"><span class="pre">n_samples</span></code> rows
and <code class="docutils literal notranslate"><span class="pre">n_features</span></code> columns,
a <code class="docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code> object, or
an array of ASCII strings.</p>
</li>
</ul>
<p class="rubric">References</p>
<dl class="citation">
<dt class="label" id="r1af812c21110-1"><span class="brackets">1</span></dt>
<dd><p>Naidan B., Boytsov L., Malkov Y.,  Novak D.,
<em>Non-metric space library (NMSLIB) manual</em>, version 2.0, 2019.
<a class="reference external" href="https://github.com/nmslib/nmslib/blob/master/manual/latex/manual.pdf">https://github.com/nmslib/nmslib/blob/master/manual/latex/manual.pdf</a>.</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</div>


           </div>
           
          </div>
          <footer>
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
        <a href="genieclust_compare_partitions.html" class="btn btn-neutral float-right" title="genieclust.compare_partitions" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
        <a href="genieclust.html" class="btn btn-neutral float-left" title="Python Package genieclust Reference" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
        &#169; Copyright 2018-2021, Marek Gagolewski.
      <span class="lastupdated">
        Last updated on 2021-08-21T17:24:12+1000.
      </span>

    </p>
  </div>
    
    
    
    Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    
    provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>
        </div>
      </div>

    </section>

  </div>
  

  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>